<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com)
     by Daniel M Kohn (private) -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<rfc category="std" docName="draft-schott-alto-new-transport-01"
     ipr="trust200902">
  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc="yes" ?>

  <?rfc symrefs="yes" ?>

  <?rfc sortrefs="yes"?>

  <?rfc iprnotified="no" ?>

  <?rfc strict="yes" ?>

  <front>
    <title abbrev="ALTO/H2">ALTO/H2: The ALTO Protocol using HTTP/2</title>
    <author fullname="Roland Schott" initials="R." surname="Schott">
      <organization>Deutsche Telekom</organization>

      <address>
        <postal>
          <street>Heinrich-Hertz-Strasse 3-7</street>

          <city>64295 Darmstadt</city>

          <country>Germany</country>
        </postal>

        <email>Roland.Schott@telekom.de</email>
      </address>
    </author>

    <author fullname="Y. Richard Yang" initials="Y." surname="Yang">
      <organization>Yale University</organization>

      <address>
        <postal>
          <street>51 Prospect St</street>

          <city>New Haven</city>

          <region>CT</region>

          <code>06520</code>

          <country>USA</country>
        </postal>

        <email>yry@cs.yale.edu</email>
      </address>
    </author>

    <author fullname="Kai Gao" initials="K." surname="Gao">
      <organization>Sichuan University</organization>

      <address>
        <postal>

          <street></street>
          <city>Chengdu</city>

          <code>201804</code>

          <country>China</country>
        </postal>

        <email>kgao@scu.edu.cn</email>
      </address>
    </author>

    <author fullname="Jingxuan Jensen Zhang" initials="J." surname="Zhang">
      <organization>Tongji University</organization>

      <address>
        <postal>
          <street>4800 Cao'An Hwy</street>

          <city>Shanghai</city>

          <code>201804</code>

          <country>China</country>
        </postal>

        <email>jingxuan.n.zhang@gmail.com</email>
      </address>
    </author>

    <date day="23" month="May" year="2022"/>

    <area>TSV Area</area>

    <workgroup>ALTO Working Group</workgroup>

    <keyword>RFC</keyword>

    <keyword>Request for Comments</keyword>

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <keyword>Application-Layer Traffic Optimization, HTTP/2, SSE, Message Queue</keyword>

    <abstract>
      <t>The ALTO base protocol [RFC7285] uses HTTP/1.x as the transport protocol and hence ALTO transport includes the limitations of HTTP/1.x. ALTO/SSE [RFC8895] addresses some of the limitations, but is still based on HTTP/1.x. This document introduces ALTO new transport, which provides the transport functions of ALTO/SSE on top of HTTP/2, for more efficient ALTO transport.</t>

    </abstract>

    <note title="Requirements Language">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as described
          in BCP 14 <xref target="RFC2119"/><xref target="RFC8174"/> when,
          and only when, they appear in all capitals, as shown here.
        </t>
    </note>

  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>Application-Layer Traffic Optimization (ALTO) provides a means for network applications 
      to obtain network status information. The ALTO base protocol <xref target="RFC7285"/> is based on the sequential request and response model of HTTP/1.1 <xref target="RFC7230"/>; hence, in the base protocol, an ALTO client can issue only a sequence of requests on network information resources, and the ALTO server sends the information resources one-by-one, in the order of the request sequence.</t>

      <t>To address the use cases where an ALTO client may need to efficiently monitor changes to a set of network information resources and the protocol is still based on the HTTP/1.1 model, the ALTO Working Group introduces ALTO/SSE (ALTO Incremental Update based on Server-Sent-Event) 
      <xref target="RFC8895"/>, so that an ALTO client can manage (i.e., add and remove) a set of 
      requests maintained at an ALTO server, and the server can continuously, concurrently, and 
      incrementally push updates whenever a monitored network information resource changes. 
      Figure 1 shows the architecture and message flow of ALTO/SSE, which can be considered as a more general transport protocol than the ALTO base transport protocol.  Although ALTO/SSE allows the concurrent transport of multiple ALTO information resources, it has complexities and limitations. For example, it requires that the server provide a separate control URI, leading to complexity in management. 
      </t>

          <figure title="ALTO SSE Architecture and Message Flow." anchor="FigOverview">
    <artwork>
    <![CDATA[
 ------------------------------------------------------------------
|                                                                  |
|          +-------+         +-------+ 1. init request  +------+   |
|          |       |         |       | <-------------   |      |   |
|          |       |         |       | ------------->   |      |   |
| 3.add/   |       |         |       | 1'. control uri  |      |   |
| remove   |       |         |       |                  |      |   |
| resource |Stream |         |Update |                  |      |   |
  -------->|Control| private |Stream | 2a. data update  |Client| --
           |Server |<------->|Server | messages         |      |
  -------- |       |         |       | -------------->  |      | <-
| response |       |         |       | -------------->  |      |   |
|          |       |         |       | 2b.control update|      |   |
|          +-------+         +-------+ messages         +------+   |
|                                                                  |
 ------------------------------------------------------------------
    ]]>
    </artwork>
    </figure>

    <t>This document specifies ALTO/H2, which realizes ALTO/SSE but takes advantage of new HTTP capabilities provided by HTTP/2 <xref target="RFC7540"/>.</t>

    </section>    

    <section anchor="altoh2req" title="ALTO/H2 Design Requirements">
      <t>ALTO/H2 is designed to satisfy a set of requirements. First, it should satisfy the following requirements to realize the functions of ALTO/SSE:</t>

      <t><list style="symbols">
        <t>R0: Client can request any resource using the connection, just as using ALTO base protocol using HTTP/1.x.</t>

        <t>R1: The client can request the addition (start) of incremental updates to a resource.</t>
        <t>R2: The client can request the deletion (stop) of incremental updates to a resource.</t>
        <t>R3: The server can signal to the client the start or stop of incremental updates to a resource.</t>
        <t>R4: The server can choose the type of each incremental update endcoding, as long as the type is indicated to be acceptable by the client.</t>
      </list></t>

      <t>Following the ALTO framework <xref target="RFC7285"/> <xref target="RFC7971"/>, ALTO/H2 should still be HTTP based:</t>
      <t><list style="symbols">
        <t>R5: The design follows basic principle of HTTP---Representational State Transfer and
          hence can use only HTTP verbs (GET, POST, PUT, DELETE, HEAD).</t>
        <t>R6: The design takes advantage of HTTP/2 design features such as parallel transfer 
           and respects HTTP/2 semantics such as the semantics of PUSH_PROMISE.</t>
      </list></t>

      <t>To allow flexible deployment, the new transport protocol should be flexible:</t>
      <t><list style="symbols">
        <t>R7: The design should support capability negotiation.</t>
      </list></t>


    </section>

    <section anchor="altoh2overview" title="ALTO/H2 Design Overview">

      <t>A key design of ALTO new transport is to distinguish between information about ALTO resources and information about ALTO transport. It introduces the following transport information structures to distribute ALTO information resources:</t>

      <t><list style="symbols">

        <t>The transport state from the ALTO server to an ALTO client (or a set of clients) for
        an ALTO information resource is conceptually through a transport 
        queue. A static ALTO information resource (e.g., Cost Map, Network Map) has a single transport queue, and a dynamic ALTO information resource (e.g., Filtered Cost Map) may create a queue for each unique filter request.</t>

        <t>Each transport queue maintains two states: (1) the incremental update message queue, which includes a sequence of incremental update messages 
        and (2) the receiver set, which includes the set of receivers receiving incremental push updates from the ALTO server. </t>

        <t>The transport queue state is exposed to clients through views; that is, a client can see only a virtual view of the server state.</t>
      </list></t>

      <t>Figure 2 shows an example illustrating the aforementioned information. Each ALTO client 
        (Client 1, Client 2, Client 3) maintains a single HTTP/2 connection with the ALTO server.
        [TODO: Add more elaboration.]
      </t>
          
      <figure title="ALTO New Transport Information Structure." anchor="FigInfoStruct">
      <artwork>
    <![CDATA[
Information Resource:

a) Static resource such as NetworkMap
b) Filterable resource such as FilteredCostMap


                              +-------------+
                              |             |
         +--------------------| ALTO Server |-----------+
         |                  +-|             |-+         |
         |                  | +-------------+ |         |
         |                  |                 |         |
---------|------------------|-----------------|---------|------------
         |                  |                 |         | Information
         |                  |                 |         | Resource
+-------------+   +-------------+   +-------------+   +-------------+ 
| Information |   | Information |   | Information |   | Information | 
| Resource #1 |   | Resource #2 |   | Resource #3 |   | Resource #4 | 
+-------------+   +-------------+   +-------------+   +-------------+ 
       |                              /    \
-------|-----------------------------/------\------------------------ 
       |                            /        \            Transport
       |                      +----/          \------+    Queue
       |                      |                      |
  +--------+             +--------+             +--------+
  |   tq1  |-----+       |   tq2  |-----+       |   tq3  |-----+
  +----|---+     |       +----|---+     |       +----|---+     |
       |         |            |         |            |         |
  +----|---+ +---|----+  +----|---+ +---|----+  +----|---+ +---|----+
  | tq1/uq | | tq1/rs |  | tq2/uq | | tq2/rs |  | tq3/uq | | tq3/rs |
  +--------+ +--------+  +--------+ +--------+  +--------+ +--------+
       |\       /\              |         /           |          |
-------|-\-----/--\-------------|--------/------------|----------|---
       |  \   /    +-------+    |       /             |          |
       |   +-/-----------+  \   |      /              |          |
       |    /             \  \  |     /               +          +
       |   /            +--\--\-|----/--+ single       \        /
       |  /             +---\--\|---/---+ http2/3       \      /
   +----------+             +----------+    connection +----------+
   | Client 1 |             | Client 2 |               | Client 3 |
   +----------+             +------- --+               +----------+

tq    = transport queue
tq/uq = incremental updates queue
sq/rs = receiver set
    ]]>
      </artwork>
      </figure>

      <t>The basic work flow of a client connecting to an ALTO server is the following:</t>

      <figure title="ALTO New Transport Information Structure." anchor="FigInfoWorkflow">
      <artwork>
    <![CDATA[

    Client opens a connection to the server
    Client opens/identifies a transport queue tq
      Client requests transport queue status of tq
      Client requests an element in the incremental update queue

      Client becomes a receiver [TODO: clear the 
            concurrency, or initial is possible]
      Client receives incremental push updates
    Client closes the transport queue tq
    Client closes the connection
    ]]>
      </artwork>
      </figure>

    </section> <!-- End of overview section -->

    <section anchor="altoh2tq" title="Transport Queue">

      <section anchor="altoh2tqops" title="Transport Queue Operations">

        <t>A transport queue supports three basic operations (CRD): create, read 
        (get status), and delete. [TODO: fix or not]
        </t>

        <t>Create a transport queue: [TODO: What is the structure] An ALTO client creates a transport queue using the HTTP POST method with ALTO SSE AddUpdateReq 
        ([RFC 8895] Sec. 6.5) as the parameter: 
        </t>

        <figure>
        <artwork>
      <![CDATA[
    object {
        ResourceID   resource-id;
        [JSONString  tag;]
        [Boolean     incremental-changes;]
        [Object      input;]
     } AddUpdateReq;

          ]]>
        </artwork>
        </figure>

        <t>A successful POST request MUST return the URI for the transport queue. Unless the request has incremental-changes to be false, the client is added to receiver set as well, indicating that the client will receive automatic, incremental push updates. </t>

        <t>Read a transport queue: A client reads the status of a transport queue by issuing a GET request to the transport queue URI returned from the POST method. [TODO: alto-transport structure; meta or not]</t>

        <t>Delete a transport queue: a transport queue exposed to a client can be closed (deleted) either explicitly or implicitly.</t>

        <t><list style="symbols">
          <t>Explicit delete: A client uses the HTTP DELETE method to explicitly delete a transport 
          queue. If successful, the transport queue is deleted from the local view of the client, although the server may still maintain the transport queue for other client connections.
          </t>

          <t>Implicit delete: Transport queue for a client is ephemeral: the close of the HTTP connection between the client and the server deletes the transport queue from the client’s view --- when the client reconnects, the client MUST NOT assume that the transport queue is still valid.
          </t>
        </list></t>

        <t>Error codes: ALTO/H2 uses HTTP error codes. [High level guidance of error code; JSON error code guidance]</t>

      </section> <!-- transport queue section operation -->

      <section anchor="altoh2tqexamples" title="Examples">
        <t>The first example is a client creating a transport queue.</t>
        <figure>
        <artwork><![CDATA[
   Client -> server request

   HEADERS
     - END_STREAM
     + END_HEADERS
       :method = POST
       :scheme = https
       :path = /tqs
       host = alto.example.com
       accept = application/alto-error+json,
                    application/alto-transport+json
       content-type = application/alto-transport+json 
                        [TODO: SSE stream control type]
       content-length = TBD

   DATA
    - END_STREAM
    {
       "resource-id": "my-routingcost-map"
    }
          ]]>
        </artwork>
        </figure>

        <figure>
        <artwork><![CDATA[

   Server -> client response:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/alto-transport+json
       content-length = TBD
   
   DATA
     - END_STREAM
      {"tq": “/tqs/2718281828459”}

          ]]>
        </artwork>
        </figure>

        <t>The client can then read the status of the transport queue using the read operation 
          (GET) in the same HTTP connection. Below is an example (structure of incremental updates queue will be specified in the next section):</t>
        <figure>
        <artwork><![CDATA[
   Client -> server request

   HEADERS
     - END_STREAM
     + END_HEADERS
       :method = GET
       :scheme = https
       :path = /tqs/2718281828459
       host = alto.example.com
       accept = application/alto-error+json,
                    application/alto-transport+json

   Server -> client response:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/alto-transport+json
       content-length = TBD
   
   DATA
     - END_STREAM
    { "uq":
       [ 
         {“seq”:        101, 
          "media-type": "application/alto-costmap+json",
          “tag”:        "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe" }, 
         {“seq”:        102, 
          "media-type": "application/merge-patch+json",
          “tag”:        "cdf0222x59740b0b2e3f8eb1d4785acd42231bfe" },
         {“seq”:        103, 
          "media-type": "application/merge-patch+json",
          “tag”:        "8eb1d4785acd42231bfecdf0222x59740b0b2e3f",
          "link":       "/tqs/2718281828459/snapshot/2e3f"} 
 
       ],
     "rs": ["self"]
    }

          ]]></artwork>
        </figure>
      </section>

    </section> <!-- transport queue section -->

    <section anchor="altoh2uq" title="Incremental Updates Queue">

      <section anchor="altoh2uqops" title="Incremental Updates Queue Operations">
        <t>Among the CRUD operations, an incremental updates queue supports only the 
          read operation: a client cannot create, update, or delete incremental updates queue directly---it is read only, and associated with transport queue automatically.</t>

        <t>Reads an incremental updates queue: A client reads the status of an incremental updates queue using the HTTP GET method: GET transport-queue-uri/uq, where the transport-queue-uri is
        the URI returned in the transport queue create method.
        </t>

        <t>The response informs the client the backlog status, and potential direct links.
          Specifically, the response is a JSON array, with each element being one incremental 
          update, with three required fields and one optional field:</t>

        <t><list style="symbols">
          <t>"seq": a required JSON integer indicating the sequence number of the incremental update; As JSON allows a large integer space, when the server reaches the largest integer, the server SHOULD close the incremental update queue; [TODO: check the spec on integer; tradition is to treat the space as a ring, but here is an interval and hence cannot wrap around]</t>
          <t>"media-type", a required JSON string giving the type of the incremental update  (see ALTO/SSE);</t>
          <t>"tag": a required JSON string giving a unique tag (see [RFC7285]; </t>
          <t>"link": an optional JSON string giving an optional link for a client to directly request a resource as a complete snapshot (not through incremental updates). [TODO: relative or can be absolute]</t>
        </list></t>

        <t>Note that the server determines the state (window of history and type of each update) 
          in the incremental updates queue, as specified by [R4].</t>

      </section>

      <section anchor="altoh2uqexamples" title="Examples">
        <t>Assume the same example in the preceding section. The client can check the status of the incremental updates queue of a transport queue from the same connection:</t>


        <figure>
          <artwork><![CDATA[
   Client -> server request:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :method = GET
       :scheme = https
       :path = /tqs/2718281828459/uq
       host = alto.example.com
       accept = application/alto-error+json,
                    application/alto-transport+json

   Server -> client response:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/alto-transport+json
       content-length = TBD
   
   DATA
     - END_STREAM
    { 
      "meta": {...}, // TODO: notification of incremental 
                        updates queue closed
      "queue":
       [ 
         {“seq”:        101, 
          "media-type": "application/alto-costmap+json",
          “tag”:        "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe" }, 
         {“seq”:        102, 
          "media-type": "application/merge-patch+json",
          “tag”:        "cdf0222x59740b0b2e3f8eb1d4785acd42231bfe" },
         {“seq”:        103, 
          "media-type": "application/merge-patch+json",
          “tag”:        "8eb1d4785acd42231bfecdf0222x59740b0b2e3f",
          "link":       "/tqs/2718281828459/snapshot/2e3f"},
          // design 1 -- end of stream record
          {“seq”:        -1, // FFFFF}
           // design 2: add an attribute to each entry
          {“seq”:        101, // seq will be binded to uint; 
                               but now w/ -1, int
           "queue-status": closed,  // json binding always 
                                       need a queue-status field
          "media-type": "application/alto-costmap+json",
          “tag”:        "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe" }, 

       ],
     
    }
          ]]></artwork>
        </figure>
      </section>

    </section> <!-- Incremental Update Message Queue Section -->

    <section anchor="altoh2updates" title="Individual Updates">

      <section anchor="altoh2updatesops" title="Individual Updates Operations">

        <t>A client can only read an individual update. The read can be either pull read issued by the client or a push from the server to the client.</t>

        <t>Client pull read: A client uses HTTP GET method on the incremental updates queue concatenated by the "seq" to pull an individual update.</t>

        <t>Server push read: a client starts to receive server push when it is added to the receiver set. A client can add itself to the receiver set when creating the transport queue, or add itself explicitly to the receiver set (see the next section).</t>

        <t>The work flow of server push of individual updates is the following:</t>

        <t><list style="symbols">
          <t>Initialization: the first update pushed from the server to the client MUST be the 
            later of the following two: (1) the last independent update in the incremental updates queue; and (2) the following entry of the entry that matches the tag when the client creates the transport queue. The client MUST set SETTINGS_ENABLE_PUSH to be 
            consistent. [TODO: HTTP/2 specific; make it generic, if so what macro/constant?]</t>
          <t>Push state: the server MUST maintain the last entry pushed to the client (and hence per client, per connection state) and schedule next update push accordingly.</t>
          <t>Push management: The client MUST NOT cancel (RST_STREAM) a PUSH_PROMISE to avoid complex server state management.</t>
        </list></t>

      </section>

      <section anchor="altoh2updatesexamples" title="Examples">

        <t>The first example is a client pull example, in which the client directly requests an 
          individual update. </t>

        <figure>
        <artwork><![CDATA[
   Client -> server request:

   HEADERS
     + END_STREAM
     + END_HEADERS
       :method = GET
       :scheme = https
       :path = /tqs/2718281828459/uq/101
       host = alto.example.com
       accept = application/alto-error+json,
                    application/alto-costmap+json

   Server -> client response:

   HEADERS
     - END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/alto-costmap+json
       content-length = TBD
   
   DATA
     + END_STREAM
    {
      "meta" : {
         "dependent-vtags" : [{
            "resource-id": "my-network-map",
            "tag": "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
          }],
         "cost-type" : {
           "cost-mode"  : "numerical",
           "cost-metric": "routingcost"
         },
         "vtag": {
           "resource-id" : "my-routingcost-map",
           "tag" : "3ee2cb7e8d63d9fab71b9b34cbf764436315542e"
         }
      },
      "cost-map" : {
        "PID1": { "PID1": 1,  "PID2": 5,  "PID3": 10 },
        "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
        "PID3": { "PID1": 20, "PID2": 15  }
      }
   }

          ]]></artwork>
        </figure>
        <t>Note from the transport queue state that the 103 message has an OPTIONAL link to a complete snapshot, which a client can request.</t>

        <t>Instead of directly requesting, the client can wait for the server for
        incremental push, where the server first sends PUSH_PROMISE with the GET URI 
        as above.</t>

        <figure>
          <artwork><![CDATA[
   Server -> client PUSH_PROMISE in current stream:

   PUSH_PROMISE     
     - END_STREAM
       Promised Stream 4
       HEADER BLOCK
       :method = GET
       :scheme = https
       :path = /tqs/2718281828459/uq/101
       host = alto.example.com
       accept = application/alto-error+json,
                    application/alto-costmap+json

   Server -> client content Stream 4:

   HEADERS
     + END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/alto-costmap+json
       content-length = TBD
   
   DATA
     + END_STREAM
    {
      "meta" : {
         "dependent-vtags" : [{
            "resource-id": "my-network-map",
            "tag": "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
          }],
         "cost-type" : {
           "cost-mode"  : "numerical",
           "cost-metric": "routingcost"
         },
         "vtag": {
           "resource-id" : "my-routingcost-map",
           "tag" : "3ee2cb7e8d63d9fab71b9b34cbf764436315542e"
         }
      },
      "cost-map" : {
        "PID1": { "PID1": 1,  "PID2": 5,  "PID3": 10 },
        "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
        "PID3": { "PID1": 20, "PID2": 15  }
      }
   }

   Server -> client PUSH_PROMISE in current stream:

   PUSH_PROMISE     
     - END_STREAM
       Promised Stream 6
       HEADER BLOCK
       :method = GET
       :scheme = https
       :path = /tqs/2718281828459/uq/102
       host = alto.example.com
       accept = application/alto-error+json,
                    application/merge-patch+json

   Server -> client content Stream 6

   HEADERS
     + END_STREAM
     + END_HEADERS
       :status = 200
       content-type = application/merge-patch+json
       content-length = TBD
   
   DATA
     + END_STREAM
    { ...}

          ]]></artwork>
        </figure>

      </section> <!-- individual example -->

    </section> <!-- individual -->

    <section anchor="altoh2rs" title="Receiver Set">

      <section anchor="altoh2rsops" title="Receiver Set Operations">
        <t>Among the CRUD operations, a client can add to or delete itself from the receiver set of a transport queue. It can also read the status of the receiver set.</t>

        <t>Creat: A client can add itself in the receiver set by using the HTTP PUT method: DELETE transport-queue/rs/self</t>

        <t>Read: A client can see only itself in the receiver set. The appearance of self in the receiver set (read does not return not exists) is an indication that push starts.</t>

        <t>Delete: A client can delete itself (stops receiving push) either explicitly or 
          implicitly.</t>

        <t><list style="symbols">
          <t>Explicit delete: A client deletes itself using the HTTP DELETE method:  
            DELETE transport-queue/rs/self.</t>
          <t>Implicit delete: Transport queue is connection ephemeral: close of connection or stream for the transport queue deletes the transport queue (from the view) for 
            the client.</t>
        </list></t>


      </section>

      <section anchor="altoh2rsexample" title="Examples">
        <t>A client can stop incremental push updates by sending the request:</t>
        <figure>
          <artwork><![CDATA[
   DELETE /tqs/2718281828459/rs/self HTTP/2
   Accept: application/alto-transport+json


   HTTP/2 200 OK
          ]]></artwork>
        </figure>

      </section> <!-- rs examples -->

    </section> <!-- receiver set -->

    <section anchor="altoh2streams" title="ALTO/H2 Stream Management">
       <section anchor="altoh2streamsobj" title="Objectives">

          <t>A main benefit of using HTTP/2 for ALTO is to take advantage of HTTP/2 streams. In particular, the objectives of ALTO/H2 include: [TODO: more elaboration]</t>

          <t><list style="symbols">
            <t>Allow stream concurrency to reduce latency</t>
            <t>Minimize the number of streams created</t>
            <t>Enforce dependency among streams (so that if A depends on B, then A should be sent before B)</t>
            <t>Encode dependency to enforce semantics (correctness)</t>
          </list></t>
          
          <t>To realize the objectives specified in the preceding section, ALTO/H2 MUST satisfy the following stream management requirements in all 4 phases specified in the next 4 subsections.</t>

       </section>

       <section anchor="altoh2streamcreatetq" title="Client -> Server [Create Transport Queue]">
          <t>Each request to create a transport queue (POST) MUST choose a new client selected stream ID (SID_tq), with the following requirements:</t>
          <t><list style="symbols">
            <t>Stream Identifier of the frame is a new client-selected stream ID; Stream Dependency in HEADERS is 0 (connection) for an independent resource, the other transport queue if the dependency is known.</t>
            <t>Invariant: Stream keeps open until close or error.</t>
          </list></t>
       </section>

       <section anchor="altoh2streamclosetq" title="Client -> Server [Close Transport Queue]">
          <t>DELETE to close a transport queue (SID_tq) MUST be sent in SID_tq, with the following requirements:</t>

          <t><list style="symbols">
            <t>Stream Identifier of the frame is SID_tq, and Stream Dependency in HEADER is 0 
              (connection), so that a client cannot close a different stream.</t>
            <t>HEADERS indicates END_STREAM; server response SHOULD close the stream.</t>
          </list></t>

       </section>

       <section anchor="altoh2streamread" title="Client -> Server [Request on Data of a Transport Queue on Stream SID_tq]">
          <t>The request and response MUST satisfy the following requirements:</t>
          <t><list style="symbols">
            <t>The Stream Identifier of the frame is a new client-selected stream ID, and Stream Dependency in HEADERs MUST be SID_tq, so that a client cannot issue request on a closed transport queue;</t>
            <t>Both the request and the response MUST indicate END_STREAM.</t>
          </list></t>        
       </section>

       <section anchor="altoh2streampush" title="Server -> Client [PUSH_PROMISE for Transport Queue on Stream SID_tq]">
          <t>The server push MUST satisfy the following requirements:</t>
          <t><list style="symbols">
            <t>PUSH_PROMISE MUST be sent in stream SID_tq to serialize to allow the client to know the push order;</t>
            <t>Each PUSH_PROMISE chooses a new server-selected stream ID, and the stream is closed after push.</t>
          </list></t>

       </section>

       <section anchor="altoh2streamconc" title="Concurrency Management">
          <t></t>
          <t><list style="symbols">
            <t>ALTO/H2 must allow concurrency control using the SETTINGS_MAX_CONCURRENT_STREAMS option in HTTP/2.</t>
            <t>From the client to the server direction, there MUST be one stream for each open transport 
              queue, and hence a client can always close a transport queue (which it uses to open the stream) and hence can also close, without the risk of deadlock.</t>
            <t>From the server to the client direction, each push needs to open a new stream and this should be controlled bu SETTINGS_MAX_CONCURRENT_STREAMS.</t>
          </list></t>

       </section>
     
    </section>

    <section anchor="altoh2ird" title="ALTO/H2 Information Resource Directory (IRD)">

      <t>Extending the IRD example in Section 8.1 of <xref target="RFC8895"/>, below is the IRD of an ALTO server supporting ALTO base protocol, ALTO/SSE, and ALTO/H2.</t>

      <t>In particular, </t>


      <figure>
        <artwork><![CDATA[
  "my-network-map": {
    "uri": "https://alto.example.com/networkmap",
    "media-type": "application/alto-networkmap+json",
  },
  "my-routingcost-map": {
    "uri": "https://alto.example.com/costmap/routingcost",
    "media-type": "application/alto-costmap+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-routingcost"]
    }
  },
  "my-hopcount-map": {
    "uri": "https://alto.example.com/costmap/hopcount",
    "media-type": "application/alto-costmap+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-hopcount"]
    }
  },
  "my-filtered-cost-map": {
    "uri": "https://alto.example.com/costmap/filtered/constraints",
    "media-type": "application/alto-costmap+json",
    "accepts": "application/alto-costmapfilter+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-routingcost", "num-hopcount"],
      "cost-constraints": true
    }
  },
  "my-simple-filtered-cost-map": {
    "uri": "https://alto.example.com/costmap/filtered/simple",
    "media-type": "application/alto-costmap+json",
    "accepts": "application/alto-costmapfilter+json",
    "uses": ["my-networkmap"],
    "capabilities": {
      "cost-type-names": ["num-routingcost", "num-hopcount"],
      "cost-constraints": false
    }
  },
  "my-props": {
    "uri": "https://alto.example.com/properties",
    "media-type": "application/alto-endpointprops+json",
    "accepts": "application/alto-endpointpropparams+json",
    "capabilities": {
      "prop-types": ["priv:ietf-bandwidth"]
    }
  },
  "my-pv": {
    "uri": "https://alto.example.com/endpointcost/pv",
    "media-type": "multipart/related;
                   type=application/alto-endpointcost+json",
    "accepts": "application/alto-endpointcostparams+json",
    "capabilities": {
      "cost-type-names": [ "path-vector" ],
      "ane-properties": [ "maxresbw", "persistent-entities" ]
    }
  },
  "update-my-costs": {
    "uri": "https://alto.example.com/updates/costs",
    "media-type": "text/event-stream",
    "accepts": "application/alto-updatestreamparams+json",
    "uses": [
       "my-network-map",
       "my-routingcost-map",
       "my-hopcount-map",
       "my-simple-filtered-cost-map"
    ],
    "capabilities": {
      "incremental-change-media-types": {
        "my-network-map": "application/json-patch+json",
        "my-routingcost-map": "application/merge-patch+json",
        "my-hopcount-map": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  },
  "update-my-costs-h2": {
    "uri": "https://alto.example.com/updates-h2/costs",
    "media-type": "application/alto-h2",
    "accepts": "application/alto-updatestreamparams+json",
    "uses": [
       "my-network-map",
       "my-routingcost-map",
       "my-hopcount-map",
       "my-simple-filtered-cost-map"
    ],
    "capabilities": {
      "incremental-change-media-types": {
        "my-network-map": "application/json-patch+json",
        "my-routingcost-map": "application/merge-patch+json",
        "my-hopcount-map": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  },

  "update-my-props": {
    "uri": "https://alto.example.com/updates/properties",
    "media-type": "text/event-stream",
    "uses": [ "my-props" ],
    "accepts": "application/alto-updatestreamparams+json",
    "capabilities": {
      "incremental-change-media-types": {
        "my-props": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  },
  "update-my-pv": {
    "uri": "https://alto.example.com/updates/pv",
    "media-type": "text/event-stream",
    "uses": [ "my-pv" ],
    "accepts": "application/alto-updatestreamparams+json",
    "capabilities": {
      "incremental-change-media-types": {
        "my-pv": "application/merge-patch+json"
      },
      "support-stream-control": true
    }
  }
  ]]></artwork>
      </figure>

    <t>Note that it is straightforward for an ALTO sever to run HTTP/2 and support concurrent retrieval of multiple resources such as "my-network-map" and "my-routingcost-map" using multiple HTTP/2 streams with the need to introducing ALTO/H2.</t>

    <t>The resource "update-my-costs-h2" provides an ALTO/H2 based connection, and this is indicated by the media-type "application/alto-h2". For an ALTO/H2 connection, the client can send in a sequence of control requests using media type application/alto-updatestreamparams+json. The server creates HTTP/2 streams and pushes updates to the client.</t>

    </section>

    <section anchor="secconsider" title="Security Considerations">
      <t>The properties defined in this document present no security
      considerations beyond those in Section 15 of the base ALTO specification
      [RFC7285].</t>
    </section>

    <section anchor="ianaconsider" title="IANA Considerations">
      <t>IANA will need to register a new media type application/alto-transport+json under ALTO registry as defined in 
        [RFC7285].</t>
    </section>

    <section title="Acknowledgments">
      <t>The authors of this document would also like to thank many
      for the reviews and comments.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
    <?rfc include="reference.RFC.2119.xml"?>  <!-- requirements words -->
    <?rfc include="reference.RFC.7230.xml"?>  <!-- HTTP/1.1 -->        
    <?rfc include="reference.RFC.7285.xml"?>  <!-- alto base -->   
    <?rfc include="reference.RFC.7540.xml"?>  <!-- HTTP/2 -->     
    <?rfc include="reference.RFC.8174.xml"?>  <!-- requirements words -->    
    <?rfc include="reference.RFC.8895.xml"?>  <!-- ALTO SSE -->
    </references>

    <references title="Informative References">            

      <?rfc include="reference.RFC.7971.xml"?>  <!-- requirements -->

    </references>

    <section title="Outlook to ALTO with HTTP/3">
      <t>This draft is focusing on HTTP/2 enhancement of the ALTO protocol and the 
design takes advantage of HTTP/2 design features such as parallel transfer 
and respects HTTP/2 semantics (e.g., PUSH_PROMISE). Since QUIC and HTTP/3 
respectively are coming up for various protocols on the Internet it is 
understandable that the question arises, if ATLO could also take 
advantage of the advantages of HTTP/3. QUIC can be seen as a replacement 
for TCP+TLS+HTTP2. HTTP/3 bases on the QUIC transport protocol and uses 
UDP instead of a TCP connection.</t>

      <t>QUIC has been developed by the IETF QUIC Working Group with the 
following goals:</t>

      <t><list style="symbols">
        <t>Minimizing connection establishment and overall transport latency for applications, starting with HTTP/2</t>
        <t>Providing multiplexing without head-of-line blocking</t>
        <t>Requiring only changes to path endpoints to enable deployment</t>
        <t>Enabling multipath and forward error correction extensions</t>
        <t>Providing always-secure transport, using TLS 1.3 by default</t>
      </list></t>

      <t>If HTTP/3 is not supported, it automatically runs on HTTP/2. 
The prerequisite for HTTP/3 is that both client and server support it.</t>

      <t>The basic assumption is that an implementation that runs on HTTP/2 should 
also run-on HTTP/3. This should be transparent. 
HTTP/3 uses "well known port" UDP 443 analogous to TCP 443. 
The network between client and server must not filter HTTP/3.</t>

      <t>Since many applications still using HTTP/2 it is mandatory for ALTO 
to support this protocol first. This ensures compatibility. 
Therefore, this document describes the update of ALTO from HTTP/1.x 
to HTTP/2. The usage of HTTP/3 will be described in a separate 
document so that compatibility of ALTO with HTTP/3 will be ensured 
in a later stage.</t>
    </section>

  </back>
</rfc>